package Report;
use Moose;
use MooseX::ClassAttribute;
use parent qw(Exporter);
use Expense;
use Carp;
use PhonyBone::FileUtilities qw(warnf);

our @EXPORT_OK=qw($EOT);
use Readonly;
Readonly my $EOT=>3_355_184_000; # some time way in the future

has 'start_ts'              => (is=>'ro', isa=>'Int', required=>1, default=>0);
has 'stop_ts'               => (is=>'ro', isa=>'Int', required=>1, default=>$EOT); 
has 'code'                  => (is=>'ro', isa=>'Int');
has 'cursor'                => (is=>'rw', isa=>'MongoDB::Cursor');

has 'bcbm'                  => (is=>'ro', isa=>'HashRef', lazy=>1, builder=>'by_code_by_month');
has 'codes'                 => (is=>'ro', isa=>'Codes', default=>sub { Codes->instance->load });
has 'mks'                   => (is=>'rw', isa=>'ArrayRef[Int]'); # sortable list of month keys as generated by month_key (see also yek_htnom)

class_has 'primary_key'     => (is=>'ro', isa=>'Str', default=>'');
class_has 'db_name'         => (is=>'rw', isa=>'Str', default=>'money');
class_has 'collection_name' => (is=>'rw', isa=>'Str', default=>'budget');
with 'Mongoid';

use Data::Dumper;
use DateTime;


# muck around with @_
# convert a date string (mm/yy or mm/dd/yy) into seconds since the epoch:
# converts $args{start} to $args{start_ts} (likewise stop & stop_ts)
around BUILDARGS => sub {
    my $orig  = shift;
    my $class = shift;

    my %args=@_;
    date2epoch(\%args, 'start');
    date2epoch(\%args, 'stop');

    sub date2epoch {
	my ($args,$key)=@_;
	my $ts_key=$key.'_ts';
	
	if (my $start=$args->{$key}) {
	    my @date=split('/', $start,3);
	    my ($m,$d,$y);
	    if (@date==2) {	# fixme: edge case for $key eq 'stop && @date==2: we actually want the last second of the previous day
		($m,$y)=@date;
		$d=1;
	    } elsif (@date==3) {
		($m,$d,$y)=@date;
	    }
	    $y+=2000 unless $y > 2000;
	    my $dt=DateTime->new(day=>$d, month=>$m, year=>$y)->epoch();
	    $args->{$ts_key}=$dt;
	}
    }

    return $class->$orig(%args);
};

# Constructor args: code start_ts, stop_ts, alt: stop, start ('mm/dd/yy' format)
sub BUILD {
    my ($self)=@_;
    $self->query_db;
}

sub count { shift->cursor->count }

# query the db: return the mongoDB cursor object:
sub query_db {
    my ($self)=@_;

    my $query={ts=>{'$gte' => int($self->start_ts), '$lte' => int($self->stop_ts) }};
    $query->{code}=$self->code if defined $self->code;
    warnf "using query %s", Dumper($query);

    my $cursor=$self->mongo->find($query);
    warnf "query_db: got %d results", $cursor->count;
    $self->cursor($cursor);
    $self;
}

use overload '""' => \&as_string;
sub as_string {
    my ($self)=@_;
    my $c=$self->cursor or return 'empty line report';
    $c->reset;
    warnf "cursor->count is %d", $c->count;
    my $str=join("\n", map { Expense->new(%$_)->as_string } $c->all);
    $c->reset;
    $str;
}

# build a hash from the report cursor
# k=month, code, v=list of $amounts
# returns [\]%bcbm
sub by_code_by_month {
    my ($self)=@_;
    warn "building report...\n";
    my $cursor=$self->cursor or die "no cursor";
    $cursor->reset;
    my %bcbm;
    my %mks;			# set of unique $mk's (month keys)

    while ($cursor->has_next) {
	my $expense=Expense->new(%{$cursor->next});
	my $mk=$self->month_key($expense);
	$bcbm{$expense->code}->{$mk} += $expense->amount;
#	warnf "bcbm{%s}->{%s}=%s (%s)\n", $expense->code, $mk, $bcbm{$expense->code}->{$mk}, $expense->amount;
	$mks{$mk}=1;		# keep track of which mks occured, for sorting later
    }

    $self->mks([keys %mks]);	# month keys
    $self->add_totals_etc(\%bcbm);
    \%bcbm;
}


# add totals and averages to bcbm
# need to add monthly totals
sub add_totals_etc {
    my ($self, $bcbm)=@_;
    my $mks=$self->mks or confess "no mks";
    my %mtotals;		# total for each month

    foreach my $code (keys %$bcbm) {
	my ($total, $n)=(0,0);	# $total per code, $n months w/expenses
	my $mhash=$bcbm->{$code};
	foreach my $mk (@$mks) {
	    if (my $amount=$mhash->{$mk}) {
		$total+=$amount;
		$n++;
		$mtotals{$mk}+=$amount;
	    } else {
		$mhash->{$mk}=0.0; # fill in missing values
	    }
	}
	my $n_mons=scalar keys %$mhash;
	my $avg=$n_mons? $total/$n_mons : 0;
	my $avg0=$n? $total/$n : 0;

	$bcbm->{$code}->{total}=$total;
	$bcbm->{$code}->{avg}=$avg;
	$bcbm->{$code}->{avg0}=$avg0;
    }
    $bcbm->{mtotals}=\%mtotals;
}


# generate a key by taking ($year % 2000)*16 + $month
# eg June 2004 -> 4*16 + 6 = 70
#    Feb  2012 -> 12*16 + 2 = 194

# this allows staightforward numerical sorting
sub month_key {
    my ($self, $expense)=@_;
    (($expense->year % 2000)*16) + $expense->month;
}

# inverse of above: (sort of; returns "m/y")
sub yek_htnom {
    my ($mk)=@_;
    my $m=$mk % 16;
    my $y=int($mk / 16);
    "$m/$y";
}

sub line_report { shift->as_string }

# entry point: generate the report hash and return a string representation thereof:
sub table_report {
    my ($self)=@_;

#    $self->by_code_by_month unless $self->bcbm;
    $self->table2str;
}

sub table2str {
    my ($self)=@_;
    my $bcbm=$self->bcbm or confess "no bcbm"; # by-code-by-month hash
    my $codes=$self->codes;
    my @lines;

    # get sorted months:
    my $mks=$self->mks or confess "no mks"; # month keys
    my $mons=join('', map {sprintf("%10s", yek_htnom($_))} sort @$mks); # each elem should be like m/yy
    my $avgs=join('', map {sprintf(" %10s", $_)} qw(total avg avg0));
    push @lines, sprintf("%30s %s %s", ' 'x15, $mons, $avgs);

    foreach my $code (keys %$bcbm) {
	next if $code eq 'mtotals';
	my $mhash=$bcbm->{$code} or confess "no bcbm hash for $code";
	my @amnts;
	foreach my $mk (sort @$mks) {
	    my $amnt=$mhash->{$mk}? sprintf("%10.2f", $mhash->{$mk}) : '    --    ';
	    push @amnts, $amnt;
	}
	my $amnts=join('', @amnts);

	my $line=sprintf("%30s %s  %10.2f %10.2f %10.2f", 
			 ($codes->get($code) || $code),
			 $amnts,
			 ($mhash->{total} || 0),
			 ($mhash->{avg0} || 0),
			 ($mhash->{avg} || 0));
	push @lines, $line;
    }
    push @lines, $self->monthly_totals_line;
    
    join("\n", @lines);
}

sub monthly_totals_line {
    my ($self)=@_;
    my $bcbm=$self->bcbm or confess "no bcbm";
    my $mtotals=$bcbm->{mtotals} or confess "no mtotals";
    my @mtotals=map {sprintf '%10.2f', $mtotals->{$_}} grep {defined $mtotals->{$_}} sort @{$self->mks};
    join('', '               Monthly totals: ', @mtotals);
}

1;
